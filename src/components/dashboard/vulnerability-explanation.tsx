'use client';

import React, { useEffect, useState, useMemo } from 'react';
import { getVulnerabilityExplanation } from '@/actions/explain-vulnerability';
import type { Host } from '@/types/nmap';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Loader2, Terminal } from 'lucide-react';
import { useLocale, useTranslations } from 'next-intl';
import { useScanStore } from '@/store/use-scan-store';
import type { ExplainVulnerabilityRiskOutput } from '@/ai/types';

interface VulnerabilityExplanationProps {
  host: Host;
  isOpen: boolean;
}

export function VulnerabilityExplanation({ host, isOpen }: VulnerabilityExplanationProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const t = useTranslations('VulnerabilityExplanation');
  const locale = useLocale();
  
  const { explanationCache, setExplanation } = useScanStore();
  
  const cacheKey = `${host.address.addr}-${locale}`;
  const explanationResult = explanationCache.get(cacheKey);

  const riskFactorsText = useMemo(() => host.riskFactors?.join(', ') || 'N/A', [host.riskFactors]);

  useEffect(() => {
    const fetchExplanation = async () => {
      if (isOpen && !explanationResult) {
        setIsLoading(true);
        setError(null);
        try {
          const result = await getVulnerabilityExplanation(host, riskFactorsText);
          setExplanation(cacheKey, result);
        } catch (err) {
          setError(err instanceof Error ? err.message : t('errorMessage'));
        } finally {
          setIsLoading(false);
        }
      }
    };

    fetchExplanation();
  }, [host, riskFactorsText, t, isOpen, explanationResult, setExplanation, cacheKey]);

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center space-y-2 p-4">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <p className="text-sm text-muted-foreground">{t('generatingReport')}</p>
      </div>
    );
  }

  if (error) {
    return (
        <Alert variant="destructive">
            <Terminal className="h-4 w-4" />
            <AlertTitle>{t('errorTitle')}</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
        </Alert>
    );
  }

  if (!explanationResult) {
    return null;
  }
  
  const factorsToList = (explanationResult?.translatedRiskFactors?.length ?? 0) > 0 
    ? explanationResult.translatedRiskFactors 
    : host.riskFactors;

  // A simple markdown to HTML converter for lists and bold text
  const formatExplanation = (text: string) => {
    return text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/(\d+\.\s.*)/g, '<p>$1</p>') // Wrap numbered list items in paragraphs
      .replace(/\n/g, '<br />');
  };

  return (
    <div className="text-sm prose prose-sm dark:prose-invert prose-p:leading-relaxed max-w-full">
        <div dangerouslySetInnerHTML={{ __html: formatExplanation(explanationResult?.explanation || '') }} />
        <div className="mt-4">
            <h4 className="font-semibold mb-2">{t('riskFactors')}</h4>
            <ul className="list-disc pl-5 space-y-1 text-xs text-muted-foreground">
              {factorsToList?.map((factor, index) => (
                <li key={index}>{factor}</li>
              ))}
            </ul>
        </div>
    </div>
  );
}
